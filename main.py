# -*- coding: utf-8 -*-
"""main

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IFTgi_hTySTCzDjOdzZaqJxBiZq_7b33
"""

import json
import time
import random

from langchain_ollama import ChatOllama
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import PydanticOutputParser
from langchain_core.exceptions import OutputParserException

from pydantic import BaseModel, Field
from typing import Literal

class ClassificationResult(BaseModel):
  category: Literal["Support", "Bug", "Feedback"]
  sentiment: Literal["positive", "neutral", "negative"]


INPUT_PATH = "data/input.json"
OUTPUT_PATH = "data/output.json"


def build_chain():
  llm = ChatOllama(model="llama3", temperature=0)

  parser = PydanticOutputParser(pydantic_object=ClassificationResult)

  prompt = ChatPromptTemplate.from_messages(
    [("system", "Ты - классификатор пользовательских обращений сервиса доставки еды."),
      ("human",
        """
        Классифицируй обращение пользователя.

        Классы:
        1. Support - вопросы, доставка, возвраты, аккаунт
        2. Bug - технические проблемы, ошибки приложения
        3. Feedback - отзывы, жалобы, благодарности

        Определи эмоциональную окраску: positive / neutral / negative

        {format_instructions}

        Обращение пользователя: {text}
        """)]
  )

  return prompt | llm | parser


def safe_invoke(chain, text, retries=3):
  for attempt in range(retries):
    try:
      return chain.invoke({"text": text})

    except OutputParserException as e:
      print("Ответ не прошел валидацию")

    except Exception as e:
      print(f"Попытка {attempt + 1}: модель недоступна, таймаут или ошибка сети")

    time.sleep(2 ** attempt + random.random())

  raise RuntimeError("Модель недоступна")


def main():
  with open(INPUT_PATH, "r") as f:
    data = json.load(f)

  chain = build_chain()
  results = []

  for item in data:
    try:
      response = safe_invoke(chain, item["text"])

      result = {
        "id": item["id"],
        "text": item["text"],
        "category": response.category,
        "sentiment": response.sentiment
      }

    except Exception as e:
      result = {
        "id": item["id"],
        "text": item["text"],
        "category": "Support",
        "sentiment": "neutral",
        "error": str(e)
      }

    results.append(result)
    time.sleep(0.3)

  with open(OUTPUT_PATH, "w") as f:
    json.dump(results, f, ensure_ascii=False, indent=2)


if __name__ == "__main__":
  main()

